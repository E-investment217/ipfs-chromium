diff --git a/base/allocator/partition_allocator/pointers/raw_ptr.h b/base/allocator/partition_allocator/pointers/raw_ptr.h
index ac91c41a57a8a..3636be8e95465 100644
--- a/base/allocator/partition_allocator/pointers/raw_ptr.h
+++ b/base/allocator/partition_allocator/pointers/raw_ptr.h
@@ -715,7 +715,7 @@ struct TraitsToImpl {
 // compiler. We have not managed to construct such an example in Chromium yet.
 template <typename T, RawPtrTraits Traits = RawPtrTraits::kEmpty>
 class PA_TRIVIAL_ABI PA_GSL_POINTER raw_ptr {
-  using RawPtrTraits = RawPtrTraits;
+//  using RawPtrTraits = RawPtrTraits;
   // Type to return from ExtractAsDangling(), which is identical except
   // kMayDangle trait is added (if one isn't there already).
   using DanglingRawPtrType = raw_ptr<T, Traits | RawPtrTraits::kMayDangle>;
diff --git a/base/memory/ref_counted.h b/base/memory/ref_counted.h
index 9ef94d84769df..f70e30748a389 100644
--- a/base/memory/ref_counted.h
+++ b/base/memory/ref_counted.h
@@ -7,6 +7,7 @@
 
 #include <stddef.h>
 
+#include <limits>
 #include <utility>
 
 #include "base/atomic_ref_count.h"
diff --git a/base/threading/thread_local_internal.h b/base/threading/thread_local_internal.h
index ed99410ea8a31..d89d48ba981ab 100644
--- a/base/threading/thread_local_internal.h
+++ b/base/threading/thread_local_internal.h
@@ -30,8 +30,7 @@ class CheckedThreadLocalOwnedPointer {
  public:
   CheckedThreadLocalOwnedPointer() = default;
 
-  CheckedThreadLocalOwnedPointer<T>(const CheckedThreadLocalOwnedPointer<T>&) =
-      delete;
+  CheckedThreadLocalOwnedPointer(const CheckedThreadLocalOwnedPointer&) = delete;
   CheckedThreadLocalOwnedPointer<T>& operator=(
       const CheckedThreadLocalOwnedPointer<T>&) = delete;
 
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 0a338dd358391..f4ec6979fa9a0 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -2154,6 +2154,7 @@ static_library("browser") {
     "//components/infobars/content",
     "//components/infobars/core",
     "//components/invalidation/impl",
+    "//components/ipfs",
     "//components/javascript_dialogs",
     "//components/keyed_service/content",
     "//components/language/content/browser",
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index febbb4791f6a2..4947fb39c469a 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -212,6 +212,8 @@
 #include "components/error_page/common/localized_error.h"
 #include "components/error_page/content/browser/net_error_auto_reloader.h"
 #include "components/google/core/common/google_switches.h"
+#include "components/ipfs/interceptor.h"
+#include "components/ipfs/url_loader_factory.h"
 #include "components/keep_alive_registry/keep_alive_types.h"
 #include "components/keep_alive_registry/scoped_keep_alive.h"
 #include "components/language/core/browser/pref_names.h"
@@ -5735,13 +5737,12 @@ void ChromeContentBrowserClient::
         int render_frame_id,
         const absl::optional<url::Origin>& request_initiator_origin,
         NonNetworkURLLoaderFactoryMap* factories) {
-#if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(ENABLE_EXTENSIONS) || \
-    !BUILDFLAG(IS_ANDROID)
   content::RenderFrameHost* frame_host =
       RenderFrameHost::FromID(render_process_id, render_frame_id);
   WebContents* web_contents = WebContents::FromRenderFrameHost(frame_host);
-#endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(ENABLE_EXTENSIONS) || \
-        // !BUILDFLAG(IS_ANDROID)
+  network::mojom::URLLoaderFactory* default_factory = g_browser_process->system_network_context_manager()->GetURLLoaderFactory();
+  ipfs::IpfsURLLoaderFactory::Create(factories, __PRETTY_FUNCTION__,web_contents->GetBrowserContext(),default_factory);
+
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   if (web_contents) {
@@ -5886,8 +5887,8 @@ std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>
 ChromeContentBrowserClient::WillCreateURLLoaderRequestInterceptors(
     content::NavigationUIData* navigation_ui_data,
     int frame_tree_node_id) {
-  std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>
-      interceptors;
+  std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>> interceptors;
+  interceptors.push_back(std::make_unique<ipfs::Interceptor>(g_browser_process->system_network_context_manager()->GetURLLoaderFactory(), GetSystemNetworkContext()));
 #if BUILDFLAG(ENABLE_OFFLINE_PAGES)
   interceptors.push_back(
       std::make_unique<offline_pages::OfflinePageURLLoaderRequestInterceptor>(
diff --git a/chrome/common/chrome_content_client.cc b/chrome/common/chrome_content_client.cc
index db08f6151229e..e63c004ec6398 100644
--- a/chrome/common/chrome_content_client.cc
+++ b/chrome/common/chrome_content_client.cc
@@ -292,6 +292,12 @@ void ChromeContentClient::AddAdditionalSchemes(Schemes* schemes) {
 #if BUILDFLAG(IS_ANDROID)
   schemes->local_schemes.push_back(url::kContentScheme);
 #endif
+  for ( const char* ip_s : {"ipfs", "ipns"} ) {
+    schemes->standard_schemes.push_back(ip_s);
+    schemes->cors_enabled_schemes.push_back(ip_s);
+    schemes->secure_schemes.push_back(ip_s);
+    schemes->csp_bypassing_schemes.push_back(ip_s);
+  }
 }
 
 std::u16string ChromeContentClient::GetLocalizedString(int message_id) {
diff --git a/net/dns/dns_client.cc b/net/dns/dns_client.cc
index d8e9ca7aef414..99ee57d1db63a 100644
--- a/net/dns/dns_client.cc
+++ b/net/dns/dns_client.cc
@@ -100,9 +100,10 @@ class DnsClientImpl : public DnsClient {
   }
 
   bool CanUseInsecureDnsTransactions() const override {
-    const DnsConfig* config = GetEffectiveConfig();
-    return config && config->nameservers.size() > 0 && insecure_enabled_ &&
-           !config->unhandled_options && !config->dns_over_tls_active;
+    return true;
+    // const DnsConfig* config = GetEffectiveConfig();
+    // return config && config->nameservers.size() > 0 && insecure_enabled_ &&
+           // !config->unhandled_options && !config->dns_over_tls_active;
   }
 
   bool CanQueryAdditionalTypesViaInsecureDns() const override {
@@ -136,7 +137,7 @@ class DnsClientImpl : public DnsClient {
   bool SetSystemConfig(absl::optional<DnsConfig> system_config) override {
     if (system_config == system_config_)
       return false;
-
+    LOG(ERROR) << " system config changed";
     system_config_ = std::move(system_config);
 
     return UpdateDnsConfig();
@@ -145,7 +146,7 @@ class DnsClientImpl : public DnsClient {
   bool SetConfigOverrides(DnsConfigOverrides config_overrides) override {
     if (config_overrides == config_overrides_)
       return false;
-
+    LOG(ERROR) << " config overrides changed";
     config_overrides_ = std::move(config_overrides);
 
     return UpdateDnsConfig();
@@ -161,9 +162,10 @@ class DnsClientImpl : public DnsClient {
   DnsSession* GetCurrentSession() override { return session_.get(); }
 
   const DnsConfig* GetEffectiveConfig() const override {
-    if (!session_)
+    if (!session_) {
+      // LOG(ERROR) << "No session = no effective config";
       return nullptr;
-
+    }
     DCHECK(session_->config().IsValid());
     return &session_->config();
   }
@@ -243,38 +245,45 @@ class DnsClientImpl : public DnsClient {
 
  private:
   absl::optional<DnsConfig> BuildEffectiveConfig() const {
+
     DnsConfig config;
     if (config_overrides_.OverridesEverything()) {
+      LOG(ERROR) << " override all the things";
       config = config_overrides_.ApplyOverrides(DnsConfig());
     } else {
-      if (!system_config_)
+      if (!system_config_) {
+        LOG(ERROR) << " no system configs.";
         return absl::nullopt;
-
+      }
+      LOG(INFO) << " apply overrides";
       config = config_overrides_.ApplyOverrides(system_config_.value());
     }
 
     UpdateConfigForDohUpgrade(&config);
-
+    LOG(ERROR) << "config.unhandled_options=" << config.unhandled_options << ' ' << config.nameservers.size() << " nameservers...";
     // TODO(ericorth): Consider keeping a separate DnsConfig for pure Chrome-
     // produced configs to allow respecting all fields like |unhandled_options|
     // while still being able to fallback to system config for DoH.
     // For now, clear the nameservers for extra security if parts of the system
     // config are unhandled.
-    if (config.unhandled_options)
-      config.nameservers.clear();
+    // if (config.unhandled_options)
+      // config.nameservers.clear();
 
-    if (!config.IsValid())
+    if (!config.IsValid()) {
+      LOG(ERROR) << " Config is invalid.";
       return absl::nullopt;
-
+    }
     return config;
   }
 
   bool UpdateDnsConfig() {
     absl::optional<DnsConfig> new_effective_config = BuildEffectiveConfig();
 
-    if (IsEqual(new_effective_config, GetEffectiveConfig()))
+    if (IsEqual(new_effective_config, GetEffectiveConfig())) {
+      LOG(INFO) << "dns config unchanged";
       return false;
-
+    }
+    LOG(ERROR) << "updating DNS config";
     insecure_fallback_failures_ = 0;
     UpdateSession(std::move(new_effective_config));
 
@@ -293,11 +302,13 @@ class DnsClientImpl : public DnsClient {
 
     if (new_effective_config) {
       DCHECK(new_effective_config.value().IsValid());
-
+      LOG(ERROR) << "setting session new effective config";
       session_ = base::MakeRefCounted<DnsSession>(
           std::move(new_effective_config).value(), rand_int_callback_,
           net_log_);
       factory_ = DnsTransactionFactory::CreateFactory(session_.get());
+    } else {
+      LOG(ERROR) << "clearing session from empty new config";
     }
   }
 
@@ -322,6 +333,7 @@ class DnsClientImpl : public DnsClient {
 
 // static
 std::unique_ptr<DnsClient> DnsClient::CreateClient(NetLog* net_log) {
+  LOG(ERROR) << "Creating dns client from NetLog @ " << static_cast<void*>(net_log);
   return std::make_unique<DnsClientImpl>(net_log,
                                          base::BindRepeating(&base::RandInt));
 }
diff --git a/net/dns/dns_query.cc b/net/dns/dns_query.cc
index 1a898f90af429..2aa2051ebf0e3 100644
--- a/net/dns/dns_query.cc
+++ b/net/dns/dns_query.cc
@@ -106,6 +106,11 @@ DnsQuery::DnsQuery(uint16_t id,
                    const OptRecordRdata* opt_rdata,
                    PaddingStrategy padding_strategy)
     : qname_size_(qname.size()) {
+      LOG(ERROR) << "DnsQuery(" << id << ','
+        << "qname.size()=" << qname.size()
+        // << std::string_view{reinterpret_cast<char const*>(qname.data()),qname.size()}
+        << ',' << qtype << ','
+        << static_cast<void const*>(opt_rdata) << ',' << static_cast<long>(padding_strategy) << ')';
 #if DCHECK_IS_ON()
   absl::optional<std::string> dotted_name =
       dns_names_util::NetworkToDottedName(qname);
@@ -156,7 +161,9 @@ DnsQuery::DnsQuery(uint16_t id,
 }
 
 DnsQuery::DnsQuery(scoped_refptr<IOBufferWithSize> buffer)
-    : io_buffer_(std::move(buffer)) {}
+    : io_buffer_(std::move(buffer)) {
+      LOG(ERROR) << " ctor from io buffer";
+    }
 
 DnsQuery::DnsQuery(const DnsQuery& query) {
   CopyFrom(query);
@@ -228,6 +235,7 @@ uint16_t DnsQuery::qtype() const {
   base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
                           io_buffer_->data() + kHeaderSize + qname_size_),
                       &type);
+  LOG(ERROR) << "type=" << type;
   return type;
 }
 
diff --git a/net/dns/dns_response.cc b/net/dns/dns_response.cc
index 03f300c1d0bc2..57539a03d796b 100644
--- a/net/dns/dns_response.cc
+++ b/net/dns/dns_response.cc
@@ -245,6 +245,7 @@ bool DnsRecordParser::ReadRecord(DnsResourceRecord* out) {
       reader.ReadU32(&out->ttl) &&
       reader.ReadU16(&rdlen) &&
       reader.ReadPiece(&out->rdata, rdlen)) {
+    LOG(ERROR) << "type=" << out->type << " klass=" << out->klass;
     cur_ = reinterpret_cast<const char*>(reader.ptr());
     ++num_records_parsed_;
     return true;
diff --git a/net/dns/dns_response_result_extractor.cc b/net/dns/dns_response_result_extractor.cc
index 644b88f9715de..f0d6fb81c8c27 100644
--- a/net/dns/dns_response_result_extractor.cc
+++ b/net/dns/dns_response_result_extractor.cc
@@ -349,7 +349,7 @@ ExtractionError ExtractTxtResults(const DnsResponse& response,
   ExtractionError extraction_error =
       ExtractResponseRecords(response, dns_protocol::kTypeTXT, &records,
                              &response_ttl, nullptr /* out_aliases */);
-
+  LOG(ERROR) << "Err extracting TXT results: " << static_cast<long>(extraction_error);
   if (extraction_error != ExtractionError::kOk) {
     *out_results = HostCache::Entry(ERR_DNS_MALFORMED_RESPONSE,
                                     HostCache::Entry::SOURCE_DNS);
diff --git a/net/dns/dns_transaction.cc b/net/dns/dns_transaction.cc
index 1ba2317ca581f..d258448c86825 100644
--- a/net/dns/dns_transaction.cc
+++ b/net/dns/dns_transaction.cc
@@ -206,7 +206,9 @@ class DnsUDPAttempt : public DnsAttempt {
         socket_(std::move(socket)),
         server_(server),
         query_(std::move(query)),
-        udp_tracker_(udp_tracker) {}
+        udp_tracker_(udp_tracker) {
+          LOG(ERROR) << "DnsUDPAttempt ctor";
+        }
 
   DnsUDPAttempt(const DnsUDPAttempt&) = delete;
   DnsUDPAttempt& operator=(const DnsUDPAttempt&) = delete;
@@ -222,6 +224,7 @@ class DnsUDPAttempt : public DnsAttempt {
     int rv = socket_->ConnectAsync(
         server_,
         base::BindOnce(&DnsUDPAttempt::OnIOComplete, base::Unretained(this)));
+    LOG(ERROR) << "ConnectAsync for DnsUDPAttempt returned " << rv;
     if (rv == ERR_IO_PENDING) {
       return rv;
     }
@@ -262,6 +265,7 @@ class DnsUDPAttempt : public DnsAttempt {
     int rv = result;
     do {
       State state = next_state_;
+      LOG(ERROR) << "DoLoop(state=" << state << ')';
       next_state_ = STATE_NONE;
       switch (state) {
         case STATE_CONNECT_COMPLETE:
@@ -292,6 +296,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoConnectComplete(int rv) {
+    LOG(ERROR) << "DoConnectComplete(" << rv << ')';
     if (rv != OK) {
       DVLOG(1) << "Failed to connect socket: " << rv;
       udp_tracker_->RecordConnectionError(rv);
@@ -305,6 +310,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoSendQuery(int rv) {
+    LOG(ERROR) << "DoSendQuery(" << rv << ')';
     DCHECK_NE(ERR_IO_PENDING, rv);
     if (rv < 0)
       return rv;
@@ -316,6 +322,7 @@ class DnsUDPAttempt : public DnsAttempt {
   }
 
   int DoSendQueryComplete(int rv) {
+    LOG(ERROR) << "DoSendQueryComplete(" << rv << ')';
     DCHECK_NE(ERR_IO_PENDING, rv);
     if (rv < 0)
       return rv;
@@ -361,6 +368,7 @@ class DnsUDPAttempt : public DnsAttempt {
 
   void OnIOComplete(int rv) {
     rv = DoLoop(rv);
+    LOG(ERROR) << "OnIOComplete(" << rv << ')';
     if (rv != ERR_IO_PENDING)
       std::move(callback_).Run(rv);
   }
@@ -669,7 +677,9 @@ class DnsTCPAttempt : public DnsAttempt {
         socket_(std::move(socket)),
         query_(std::move(query)),
         length_buffer_(
-            base::MakeRefCounted<IOBufferWithSize>(sizeof(uint16_t))) {}
+            base::MakeRefCounted<IOBufferWithSize>(sizeof(uint16_t))) {
+              LOG(ERROR) << "DnsTCPAttempt ctor";
+            }
 
   DnsTCPAttempt(const DnsTCPAttempt&) = delete;
   DnsTCPAttempt& operator=(const DnsTCPAttempt&) = delete;
@@ -882,6 +892,7 @@ class DnsTCPAttempt : public DnsAttempt {
 
   void OnIOComplete(int rv) {
     rv = DoLoop(rv);
+    LOG(ERROR) << "OnIOComplete(" << rv << ')';
     if (rv != ERR_IO_PENDING)
       std::move(callback_).Run(rv);
   }
@@ -1198,7 +1209,9 @@ class DnsTransactionImpl : public DnsTransaction,
   struct AttemptResult {
     AttemptResult() = default;
     AttemptResult(int rv, const DnsAttempt* attempt)
-        : rv(rv), attempt(attempt) {}
+        : rv(rv), attempt(attempt) {
+          LOG(ERROR) << "AttemptResult(" << rv << ')';
+        }
 
     int rv;
     raw_ptr<const DnsAttempt, DanglingUntriaged> attempt;
@@ -1269,7 +1282,7 @@ class DnsTransactionImpl : public DnsTransaction,
 
   void DoCallback(AttemptResult result) {
     DCHECK_NE(ERR_IO_PENDING, result.rv);
-
+    LOG(ERROR) << "DoCallback";
     // TODO(mgersh): consider changing back to a DCHECK once
     // https://crbug.com/779589 is fixed.
     if (callback_.is_null())
@@ -1277,6 +1290,7 @@ class DnsTransactionImpl : public DnsTransaction,
 
     const DnsResponse* response =
         result.attempt ? result.attempt->GetResponse() : nullptr;
+    LOG(ERROR) << "In DoCallback(result.rv=" << result.rv << ')';
     CHECK(result.rv != OK || response != nullptr);
 
     timer_.Stop();
@@ -1345,7 +1359,7 @@ class DnsTransactionImpl : public DnsTransaction,
                                std::unique_ptr<DnsQuery> query) {
     DCHECK(!secure_);
     DCHECK(!session_->udp_tracker()->low_entropy());
-
+    LOG(ERROR) << "MakeUdpAttempt(" << server_index << ')';
     const DnsConfig& config = session_->config();
     DCHECK_LT(server_index, config.nameservers.size());
     size_t attempt_number = attempts_.size();
@@ -1378,6 +1392,7 @@ class DnsTransactionImpl : public DnsTransaction,
     size_t doh_server_index = dns_server_iterator_->GetNextAttemptIndex();
 
     unsigned attempt_number = attempts_.size();
+    LOG(ERROR) << "MakeHTTPAttempt(" << doh_server_index << ')';
     ConstructDnsHTTPAttempt(
         session_.get(), doh_server_index, qnames_.front(), qtype_, opt_rdata_,
         &attempts_, resolve_context_->url_request_context(),
@@ -1428,6 +1443,7 @@ class DnsTransactionImpl : public DnsTransaction,
 
   AttemptResult MakeTcpAttempt(size_t server_index,
                                std::unique_ptr<DnsQuery> query) {
+    LOG(ERROR) << "MakeTcpAttempt(" << server_index << ')';
     DCHECK(!secure_);
     const DnsConfig& config = session_->config();
     DCHECK_LT(server_index, config.nameservers.size());
@@ -1490,6 +1506,7 @@ class DnsTransactionImpl : public DnsTransaction,
                          bool record_rtt,
                          base::TimeTicks start,
                          int rv) {
+    LOG(ERROR) << "OnAttemptComplete(" << attempt_number << ',' << record_rtt << ',' << rv << ')';
     DCHECK_LT(attempt_number, attempts_.size());
     const DnsAttempt* attempt = attempts_[attempt_number].get();
     if (record_rtt && attempt->GetResponse()) {
@@ -1523,9 +1540,10 @@ class DnsTransactionImpl : public DnsTransaction,
   // Resolves the result of a DnsAttempt until a terminal result is reached
   // or it will complete asynchronously (ERR_IO_PENDING).
   AttemptResult ProcessAttemptResult(AttemptResult result) {
+    LOG(ERROR) << "ProcessAttemptResult (" << result.rv << ')';
     while (result.rv != ERR_IO_PENDING) {
       LogResponse(result.attempt);
-
+      LOG(ERROR) << "ProcessAttemptResult ... " << result.rv;
       switch (result.rv) {
         case OK:
           resolve_context_->RecordServerSuccess(result.attempt->server_index(),
diff --git a/net/dns/dns_util.cc b/net/dns/dns_util.cc
index 534d3c3d6196c..55502bad55ed6 100644
--- a/net/dns/dns_util.cc
+++ b/net/dns/dns_util.cc
@@ -124,6 +124,7 @@ uint16_t DnsQueryTypeToQtype(DnsQueryType dns_query_type) {
     case DnsQueryType::AAAA:
       return dns_protocol::kTypeAAAA;
     case DnsQueryType::TXT:
+      LOG(ERROR) << "TXT=>kTypeTXT";
       return dns_protocol::kTypeTXT;
     case DnsQueryType::PTR:
       return dns_protocol::kTypePTR;
diff --git a/net/dns/host_cache.h b/net/dns/host_cache.h
index f077893d071df..10ef0cea2078e 100644
--- a/net/dns/host_cache.h
+++ b/net/dns/host_cache.h
@@ -212,10 +212,16 @@ class NET_EXPORT HostCache {
       aliases_ = std::move(aliases);
     }
     const absl::optional<std::vector<std::string>>& text_records() const {
+      if (text_records_) {
+        LOG(INFO) << " This host entry has " << text_records_.value().size() << " TXT records.";
+      }
       return text_records_;
     }
     void set_text_records(
         absl::optional<std::vector<std::string>> text_records) {
+      if (text_records) {
+        LOG(INFO) << "set_text_records(" << text_records.value().size() << " recs)";
+      }
       text_records_ = std::move(text_records);
     }
     const absl::optional<std::vector<HostPortPair>>& hostnames() const {
@@ -303,6 +309,7 @@ class NET_EXPORT HostCache {
       endpoint_metadatas_ = std::move(endpoint_metadatas);
     }
     void SetResult(std::vector<std::string> text_records) {
+      LOG(INFO) << "SetResult(" << text_records.size() << " recs)";
       text_records_ = std::move(text_records);
     }
     void SetResult(std::vector<HostPortPair> hostnames) {
diff --git a/net/dns/host_resolver.cc b/net/dns/host_resolver.cc
index 951730bfd5994..d072de57211a1 100644
--- a/net/dns/host_resolver.cc
+++ b/net/dns/host_resolver.cc
@@ -199,6 +199,7 @@ const url::SchemeHostPort& HostResolver::Host::AsSchemeHostPort() const {
   const url::SchemeHostPort* scheme_host_port =
       absl::get_if<url::SchemeHostPort>(&host_);
   DCHECK(scheme_host_port);
+  LOG(INFO) << scheme_host_port;
   return *scheme_host_port;
 }
 
