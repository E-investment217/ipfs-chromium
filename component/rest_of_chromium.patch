diff --git a/base/allocator/partition_allocator/pointers/raw_ptr.h b/base/allocator/partition_allocator/pointers/raw_ptr.h
index ac91c41a57a8a..3636be8e95465 100644
--- a/base/allocator/partition_allocator/pointers/raw_ptr.h
+++ b/base/allocator/partition_allocator/pointers/raw_ptr.h
@@ -715,7 +715,7 @@ struct TraitsToImpl {
 // compiler. We have not managed to construct such an example in Chromium yet.
 template <typename T, RawPtrTraits Traits = RawPtrTraits::kEmpty>
 class PA_TRIVIAL_ABI PA_GSL_POINTER raw_ptr {
-  using RawPtrTraits = RawPtrTraits;
+//  using RawPtrTraits = RawPtrTraits;
   // Type to return from ExtractAsDangling(), which is identical except
   // kMayDangle trait is added (if one isn't there already).
   using DanglingRawPtrType = raw_ptr<T, Traits | RawPtrTraits::kMayDangle>;
diff --git a/base/memory/ref_counted.h b/base/memory/ref_counted.h
index 9ef94d84769df..f70e30748a389 100644
--- a/base/memory/ref_counted.h
+++ b/base/memory/ref_counted.h
@@ -7,6 +7,7 @@
 
 #include <stddef.h>
 
+#include <limits>
 #include <utility>
 
 #include "base/atomic_ref_count.h"
diff --git a/base/threading/thread_local_internal.h b/base/threading/thread_local_internal.h
index ed99410ea8a31..d89d48ba981ab 100644
--- a/base/threading/thread_local_internal.h
+++ b/base/threading/thread_local_internal.h
@@ -30,8 +30,7 @@ class CheckedThreadLocalOwnedPointer {
  public:
   CheckedThreadLocalOwnedPointer() = default;
 
-  CheckedThreadLocalOwnedPointer<T>(const CheckedThreadLocalOwnedPointer<T>&) =
-      delete;
+  CheckedThreadLocalOwnedPointer(const CheckedThreadLocalOwnedPointer&) = delete;
   CheckedThreadLocalOwnedPointer<T>& operator=(
       const CheckedThreadLocalOwnedPointer<T>&) = delete;
 
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
index 0a338dd358391..f4ec6979fa9a0 100644
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -2154,6 +2154,7 @@ static_library("browser") {
     "//components/infobars/content",
     "//components/infobars/core",
     "//components/invalidation/impl",
+    "//components/ipfs",
     "//components/javascript_dialogs",
     "//components/keyed_service/content",
     "//components/language/content/browser",
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index febbb4791f6a2..4947fb39c469a 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -212,6 +212,8 @@
 #include "components/error_page/common/localized_error.h"
 #include "components/error_page/content/browser/net_error_auto_reloader.h"
 #include "components/google/core/common/google_switches.h"
+#include "components/ipfs/interceptor.h"
+#include "components/ipfs/url_loader_factory.h"
 #include "components/keep_alive_registry/keep_alive_types.h"
 #include "components/keep_alive_registry/scoped_keep_alive.h"
 #include "components/language/core/browser/pref_names.h"
@@ -5735,13 +5737,12 @@ void ChromeContentBrowserClient::
         int render_frame_id,
         const absl::optional<url::Origin>& request_initiator_origin,
         NonNetworkURLLoaderFactoryMap* factories) {
-#if BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(ENABLE_EXTENSIONS) || \
-    !BUILDFLAG(IS_ANDROID)
   content::RenderFrameHost* frame_host =
       RenderFrameHost::FromID(render_process_id, render_frame_id);
   WebContents* web_contents = WebContents::FromRenderFrameHost(frame_host);
-#endif  // BUILDFLAG(IS_CHROMEOS_ASH) || BUILDFLAG(ENABLE_EXTENSIONS) || \
-        // !BUILDFLAG(IS_ANDROID)
+  network::mojom::URLLoaderFactory* default_factory = g_browser_process->system_network_context_manager()->GetURLLoaderFactory();
+  ipfs::IpfsURLLoaderFactory::Create(factories, __PRETTY_FUNCTION__,web_contents->GetBrowserContext(),default_factory);
+
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
   if (web_contents) {
@@ -5886,8 +5887,8 @@ std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>
 ChromeContentBrowserClient::WillCreateURLLoaderRequestInterceptors(
     content::NavigationUIData* navigation_ui_data,
     int frame_tree_node_id) {
-  std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>>
-      interceptors;
+  std::vector<std::unique_ptr<content::URLLoaderRequestInterceptor>> interceptors;
+  interceptors.push_back(std::make_unique<ipfs::Interceptor>(g_browser_process->system_network_context_manager()->GetURLLoaderFactory(), GetSystemNetworkContext()));
 #if BUILDFLAG(ENABLE_OFFLINE_PAGES)
   interceptors.push_back(
       std::make_unique<offline_pages::OfflinePageURLLoaderRequestInterceptor>(
diff --git a/chrome/common/chrome_content_client.cc b/chrome/common/chrome_content_client.cc
index db08f6151229e..e63c004ec6398 100644
--- a/chrome/common/chrome_content_client.cc
+++ b/chrome/common/chrome_content_client.cc
@@ -292,6 +292,12 @@ void ChromeContentClient::AddAdditionalSchemes(Schemes* schemes) {
 #if BUILDFLAG(IS_ANDROID)
   schemes->local_schemes.push_back(url::kContentScheme);
 #endif
+  for ( const char* ip_s : {"ipfs", "ipns"} ) {
+    schemes->standard_schemes.push_back(ip_s);
+    schemes->cors_enabled_schemes.push_back(ip_s);
+    schemes->secure_schemes.push_back(ip_s);
+    schemes->csp_bypassing_schemes.push_back(ip_s);
+  }
 }
 
 std::u16string ChromeContentClient::GetLocalizedString(int message_id) {
diff --git a/net/dns/dns_client.cc b/net/dns/dns_client.cc
index d8e9ca7aef414..99ee57d1db63a 100644
--- a/net/dns/dns_client.cc
+++ b/net/dns/dns_client.cc
@@ -100,9 +100,10 @@ class DnsClientImpl : public DnsClient {
   }
 
   bool CanUseInsecureDnsTransactions() const override {
-    const DnsConfig* config = GetEffectiveConfig();
-    return config && config->nameservers.size() > 0 && insecure_enabled_ &&
-           !config->unhandled_options && !config->dns_over_tls_active;
+    return true;
+    // const DnsConfig* config = GetEffectiveConfig();
+    // return config && config->nameservers.size() > 0 && insecure_enabled_ &&
+           // !config->unhandled_options && !config->dns_over_tls_active;
   }
 
   bool CanQueryAdditionalTypesViaInsecureDns() const override {
@@ -136,7 +137,7 @@ class DnsClientImpl : public DnsClient {
   bool SetSystemConfig(absl::optional<DnsConfig> system_config) override {
     if (system_config == system_config_)
       return false;
-
+    LOG(ERROR) << " system config changed";
     system_config_ = std::move(system_config);
 
     return UpdateDnsConfig();
@@ -145,7 +146,7 @@ class DnsClientImpl : public DnsClient {
   bool SetConfigOverrides(DnsConfigOverrides config_overrides) override {
     if (config_overrides == config_overrides_)
       return false;
-
+    LOG(ERROR) << " config overrides changed";
     config_overrides_ = std::move(config_overrides);
 
     return UpdateDnsConfig();
@@ -161,9 +162,10 @@ class DnsClientImpl : public DnsClient {
   DnsSession* GetCurrentSession() override { return session_.get(); }
 
   const DnsConfig* GetEffectiveConfig() const override {
-    if (!session_)
+    if (!session_) {
+      // LOG(ERROR) << "No session = no effective config";
       return nullptr;
-
+    }
     DCHECK(session_->config().IsValid());
     return &session_->config();
   }
@@ -243,38 +245,45 @@ class DnsClientImpl : public DnsClient {
 
  private:
   absl::optional<DnsConfig> BuildEffectiveConfig() const {
+
     DnsConfig config;
     if (config_overrides_.OverridesEverything()) {
+      LOG(ERROR) << " override all the things";
       config = config_overrides_.ApplyOverrides(DnsConfig());
     } else {
-      if (!system_config_)
+      if (!system_config_) {
+        LOG(ERROR) << " no system configs.";
         return absl::nullopt;
-
+      }
+      LOG(INFO) << " apply overrides";
       config = config_overrides_.ApplyOverrides(system_config_.value());
     }
 
     UpdateConfigForDohUpgrade(&config);
-
+    LOG(ERROR) << "config.unhandled_options=" << config.unhandled_options << ' ' << config.nameservers.size() << " nameservers...";
     // TODO(ericorth): Consider keeping a separate DnsConfig for pure Chrome-
     // produced configs to allow respecting all fields like |unhandled_options|
     // while still being able to fallback to system config for DoH.
     // For now, clear the nameservers for extra security if parts of the system
     // config are unhandled.
-    if (config.unhandled_options)
-      config.nameservers.clear();
+    // if (config.unhandled_options)
+      // config.nameservers.clear();
 
-    if (!config.IsValid())
+    if (!config.IsValid()) {
+      LOG(ERROR) << " Config is invalid.";
       return absl::nullopt;
-
+    }
     return config;
   }
 
   bool UpdateDnsConfig() {
     absl::optional<DnsConfig> new_effective_config = BuildEffectiveConfig();
 
-    if (IsEqual(new_effective_config, GetEffectiveConfig()))
+    if (IsEqual(new_effective_config, GetEffectiveConfig())) {
+      LOG(INFO) << "dns config unchanged";
       return false;
-
+    }
+    LOG(ERROR) << "updating DNS config";
     insecure_fallback_failures_ = 0;
     UpdateSession(std::move(new_effective_config));
 
@@ -293,11 +302,13 @@ class DnsClientImpl : public DnsClient {
 
     if (new_effective_config) {
       DCHECK(new_effective_config.value().IsValid());
-
+      LOG(ERROR) << "setting session new effective config";
       session_ = base::MakeRefCounted<DnsSession>(
           std::move(new_effective_config).value(), rand_int_callback_,
           net_log_);
       factory_ = DnsTransactionFactory::CreateFactory(session_.get());
+    } else {
+      LOG(ERROR) << "clearing session from empty new config";
     }
   }
 
@@ -322,6 +333,7 @@ class DnsClientImpl : public DnsClient {
 
 // static
 std::unique_ptr<DnsClient> DnsClient::CreateClient(NetLog* net_log) {
+  LOG(ERROR) << "Creating dns client from NetLog @ " << static_cast<void*>(net_log);
   return std::make_unique<DnsClientImpl>(net_log,
                                          base::BindRepeating(&base::RandInt));
 }
diff --git a/net/dns/dns_query.cc b/net/dns/dns_query.cc
index 1a898f90af429..2aa2051ebf0e3 100644
--- a/net/dns/dns_query.cc
+++ b/net/dns/dns_query.cc
@@ -106,6 +106,11 @@ DnsQuery::DnsQuery(uint16_t id,
                    const OptRecordRdata* opt_rdata,
                    PaddingStrategy padding_strategy)
     : qname_size_(qname.size()) {
+      LOG(ERROR) << "DnsQuery(" << id << ','
+        << "qname.size()=" << qname.size()
+        // << std::string_view{reinterpret_cast<char const*>(qname.data()),qname.size()}
+        << ',' << qtype << ','
+        << static_cast<void const*>(opt_rdata) << ',' << static_cast<long>(padding_strategy) << ')';
 #if DCHECK_IS_ON()
   absl::optional<std::string> dotted_name =
       dns_names_util::NetworkToDottedName(qname);
@@ -156,7 +161,9 @@ DnsQuery::DnsQuery(uint16_t id,
 }
 
 DnsQuery::DnsQuery(scoped_refptr<IOBufferWithSize> buffer)
-    : io_buffer_(std::move(buffer)) {}
+    : io_buffer_(std::move(buffer)) {
+      LOG(ERROR) << " ctor from io buffer";
+    }
 
 DnsQuery::DnsQuery(const DnsQuery& query) {
   CopyFrom(query);
@@ -228,6 +235,7 @@ uint16_t DnsQuery::qtype() const {
   base::ReadBigEndian(reinterpret_cast<const uint8_t*>(
                           io_buffer_->data() + kHeaderSize + qname_size_),
                       &type);
+  LOG(ERROR) << "type=" << type;
   return type;
 }
 
diff --git a/net/dns/dns_response.cc b/net/dns/dns_response.cc
index 03f300c1d0bc2..57539a03d796b 100644
--- a/net/dns/dns_response.cc
+++ b/net/dns/dns_response.cc
@@ -245,6 +245,7 @@ bool DnsRecordParser::ReadRecord(DnsResourceRecord* out) {
       reader.ReadU32(&out->ttl) &&
       reader.ReadU16(&rdlen) &&
       reader.ReadPiece(&out->rdata, rdlen)) {
+    LOG(ERROR) << "type=" << out->type << " klass=" << out->klass;
     cur_ = reinterpret_cast<const char*>(reader.ptr());
     ++num_records_parsed_;
     return true;
diff --git a/net/dns/dns_response_result_extractor.cc b/net/dns/dns_response_result_extractor.cc
index 644b88f9715de..f0d6fb81c8c27 100644
--- a/net/dns/dns_response_result_extractor.cc
+++ b/net/dns/dns_response_result_extractor.cc
@@ -349,7 +349,7 @@ ExtractionError ExtractTxtResults(const DnsResponse& response,
   ExtractionError extraction_error =
       ExtractResponseRecords(response, dns_protocol::kTypeTXT, &records,
                              &response_ttl, nullptr /* out_aliases */);
-
+  LOG(ERROR) << "Err extracting TXT results: " << static_cast<long>(extraction_error);
   if (extraction_error != ExtractionError::kOk) {
     *out_results = HostCache::Entry(ERR_DNS_MALFORMED_RESPONSE,
                                     HostCache::Entry::SOURCE_DNS);
diff --git a/net/dns/dns_util.cc b/net/dns/dns_util.cc
index 534d3c3d6196c..55502bad55ed6 100644
--- a/net/dns/dns_util.cc
+++ b/net/dns/dns_util.cc
@@ -124,6 +124,7 @@ uint16_t DnsQueryTypeToQtype(DnsQueryType dns_query_type) {
     case DnsQueryType::AAAA:
       return dns_protocol::kTypeAAAA;
     case DnsQueryType::TXT:
+      LOG(ERROR) << "TXT=>kTypeTXT";
       return dns_protocol::kTypeTXT;
     case DnsQueryType::PTR:
       return dns_protocol::kTypePTR;
diff --git a/net/dns/host_cache.h b/net/dns/host_cache.h
index f077893d071df..10ef0cea2078e 100644
--- a/net/dns/host_cache.h
+++ b/net/dns/host_cache.h
@@ -212,10 +212,16 @@ class NET_EXPORT HostCache {
       aliases_ = std::move(aliases);
     }
     const absl::optional<std::vector<std::string>>& text_records() const {
+      if (text_records_) {
+        LOG(INFO) << " This host entry has " << text_records_.value().size() << " TXT records.";
+      }
       return text_records_;
     }
     void set_text_records(
         absl::optional<std::vector<std::string>> text_records) {
+      if (text_records) {
+        LOG(INFO) << "set_text_records(" << text_records.value().size() << " recs)";
+      }
       text_records_ = std::move(text_records);
     }
     const absl::optional<std::vector<HostPortPair>>& hostnames() const {
@@ -303,6 +309,7 @@ class NET_EXPORT HostCache {
       endpoint_metadatas_ = std::move(endpoint_metadatas);
     }
     void SetResult(std::vector<std::string> text_records) {
+      LOG(INFO) << "SetResult(" << text_records.size() << " recs)";
       text_records_ = std::move(text_records);
     }
     void SetResult(std::vector<HostPortPair> hostnames) {
diff --git a/net/dns/host_resolver.cc b/net/dns/host_resolver.cc
index 951730bfd5994..d072de57211a1 100644
--- a/net/dns/host_resolver.cc
+++ b/net/dns/host_resolver.cc
@@ -199,6 +199,7 @@ const url::SchemeHostPort& HostResolver::Host::AsSchemeHostPort() const {
   const url::SchemeHostPort* scheme_host_port =
       absl::get_if<url::SchemeHostPort>(&host_);
   DCHECK(scheme_host_port);
+  LOG(INFO) << scheme_host_port;
   return *scheme_host_port;
 }
 
